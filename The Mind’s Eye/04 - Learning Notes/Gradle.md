2024-12-30 16:25

Status:

Tags: [[Java]]


# Gradle
- Build Automation tool
- Takes code and package it into deployable unit
- Written in Kotlin
- We can write gradle scripts using Kotlin/Groovy
- Highly configurable to meet project requirements
## Why use Gradle?
- Building and running app very easy
- No need to install Gradle
	- Gradle wrapper comes bundled with project
	- just run ./gradlew build
- It's very concise and no XML configuration
- Very fast, support parallel processing and incremental builds.

## Key Concepts :
- `build.gradle.kts` is the Gradle build script file
	- Written in Kotlin DSL
	- equivalent to maven's pom.xml file
	- present in top level of project

```kotlin
// aditional build functionality
plugins {  
    id("java")  
}  

// Metadata : Information about our build
group = "dev.shreyas"  
version = "1.0-SNAPSHOT"  

// where to find dependencies 
repositories {  
    mavenCentral()  
}  

// artifacts required for building our code
dependencies {  
    testImplementation(platform("org.junit:junit-bom:5.10.0"))  
    testImplementation("org.junit.jupiter:junit-jupiter")  
}  
  
tasks.test {  
    useJUnitPlatform()  
}
```


### 1. Gradle Task :
- Unit of work
- invoked from command line  e.g. `./gradlew build`
- See available tasks by running `./gradlew tasks`
- We can create our own tasks
- We can invoke one or many tasks from the command line
- Task have dependencies on other tasks
- We can create task graph

### 2. Wrapper :
- `gradlew`
- It is a script used to invoke Gradle and run tasks
- Always committed into VCS.
- Thus we don't need to have local installation, directly use gradle wrapper.
- It contains project specific gradle version
- It's always preferred. 

### 3. Installation : 
- Need java setup
- Download gradle zip file
- export path for /bin/
- To update gradle wrapper specific to project :
```shell
./gradlew --version // check current version
./gradlew wrapper --gradle-version <new_version>
// now check and buil our project to see everything is fine or not
```

### 4. Gradle Project Structure :
- Support both single-project and multi-project structures.
- A single-project structure is normally what you use when you have a small project to build, which produces a single build output.
```txt
|-- build.gradle.kts ① 
|-- gradle ② 
	| `-- wrapper
		|-- gradle-wrapper.jar 
		|`-- gradle-wrapper.properties 
|-- gradlew ③ 
|-- gradlew.bat ③ 
|-- settings.gradle.kts ④
|-- .gradle
```

1. `build.gradle.kts` is main build config file
2. `gradle` directory contains config for wrapper
3. `gradlew` gradle version script based on Linux
4. `gradlew.bat` for Windows
5. `settings.gradle.kts` additional config for project such as project name and more
6. `.gradle` is auto generated by Gradle. It is project specific cache used internally by Gradle
- A multi-project structure is used for a complex project which is split into several distinct components, each of which may produce their own build outputs.

### 5. Creating Gradle Project :
- Use `gradle init` command to create new Gradle project.
	1. Select type of project
	2. Select build script DSL
	3. Project name
	4. Select if you want new APIs and behavior.(They can be changed in future so generally NO)
- This gives interactive wizard. 
- We can also generate project through IDE.

- `./gradlew help` 
- `./gradlew tasks` : Display all available tasks for project.
- `./gradlew tasks --all` : By default only high level task are shown, to see all use this.
- `./gradlew <task_name>` : run specific task.
- NOTE : `/` is for Linux and `\` is in windows 

### 6. How Gradle Works With Java :
- Compile Java classes
- Manage resources
- package everything into jar, war, etc.
- run tests
- Define dependencies 
##### 6.1 Gradle Java Plugin :
```kotlin
// build.gradle.kts
plugins {
	java
}
```

1. Configures project in certain way and adds additional tasks.
2. As it's core Gradle plugin, it's maintained by core gradle team.
3. Some tasks added with gradle java plugin
	- `./gradlew compileJava` uses whatever Java installation is setup in your environment to compile your project’s .java files into .class files and put into build directory.
	- `./gradlew processResources` The task looks in specific directories in your project which have been marked as resources directories, and copies the contents into the build directory. The reason it’s called `processResources` is that it can do some additional processing along the way, such as finding and replacing strings.
	- `./gradlew jar` is used to package java compiled classes and resources into jar archive. The name of jar file is `<project name>-<version>.jar` 
	- `/gradlew test` compiles tests, process resources and run tests. It also creates test report(HTML file).
4. Define Dependencies :
	When you declare the dependency, it goes into a specific dependency configuration:
	- `implementation` is for dependencies required during compilation and execution of your code
	- `testImplementation` is similar, but is for dependencies required during compilation and execution of your tests
	It’s important you pick the correct dependency configuration,
	because they’re used to generate the Java class-path. The class-path is used by Java so it knows about all the classes required during code compilation or execution. When the compileJava Gradle task uses Java to compile your classes, the class-path must include all the relevant dependencies.
```kotlin
dependencies {   
	implementation("org.apache.commons:commons-lang3:3.13.0")
	testImplementation("org.junit.jupiter:junit-jupiter:5.10.0") 
	// Group : Name : Version
}
```
 5. Gradle java project layout :
	- `src/main/java` for classes 
	- `src/main/resources` for resources 
	- `src/test/java` for test classes 
	- `src/test/resources` for test resources
	
	- `src/main/java` classes go into `build/classes/java/main`
	- `src/main/resources` resources go into `build/resources/main`
	- `src/test/java` test classes go into `build/classes/java/test `
	- `src/test/resources` test resources go into `build/resources/test`
	As is normally the case with Gradle, these locations are configurable
	
6. `no main manifest attribute, in .\build\libs\Learn-Gradle-1.0-SNAPSHOT.jar` This error means java doesn't know which class to run within jar file. 
	This also configures the jar task to create manifest file with main class.
```kotlin
tasks.named<Jar>("jar") {  
    manifest {  
        attributes["Main-Class"] = "dev.shreyas.Main"  
    }  
}
```

##### 6.2 Java Toolchain :
Common configuration for JVM (Java) based projects.  
* This extension is added by the JavaBasePlugin and would be more appropriately named  
* the JvmPluginExtension extension. It is used to configure many of the project's  
* JVM-related settings and behavior.
```kotlin
java {  
    toolchain {  
        languageVersion = JavaLanguageVersion.of(21)   // If we don't have java 21 it will download it and use it  
        vendor = JvmVendorSpec.ORACLE  
    }  
    sourceCompatibility = JavaVersion.VERSION_21  
    targetCompatibility = JavaVersion.VERSION_21  
}
```

### 7. Kotlin Essentials For Gradle :
- Kotlin is scripting language running in JVM.
- 3 diff. between Kotlin and Java
	1. Semicolons are optional
	2. Support String interpolation
	3. `val` is used for read-only variable and `var` is for mutable variables.
```kotlin
val name = "Bob" 
var mutableName = "Bob v2"
println(name)
println("His name is ${name}")
```
- Lambda expression = pass function around, execute later
```kotlin
val lambdaExpression = {   
	for (i in 3 downTo 1) {   
		println(i) 32 of 45 
	}   
	println(" Lift off!") 
}
lambdaExpression()
// prints 321 Lift off!
```
- Lambda expressions are used heavily in the Gradle build script. Consider this repositories definition, for example
```kotlin
repositories {   
	mavenCentral()
}
// repositories is just a function call with a lambda expression as an argument. The contents of the lambda expression is mavenCentral(), which gets executed at a later point.
```

- parentheses are optional in some scenarios
	When we call the implementation function, we use parentheses to pass the dependency string argument
	However, when a lambda expression is the final argument to a function, the parentheses can be left out.
```kotlin
dependencies {   
	implementation("org.apache.commons:commons-lang3:3.13.0") 
}

repositories {   
	mavenCentral()
}
```

### 8. Gradle Task Graph :

Let’s use as an example some of the tasks added by the Java plugin. The build task depends on the assemble and check tasks.
![[GradleBuildTaskGraph.png]]
This means that when you run ./gradlew build, assemble and check get run first
The interesting thing is that the build task itself doesn’t do anything when it’s run It’s only there to aggregate both the assemble and check tasks together. 
- assemble : handles building your project including creating artifacts such as jar files. 
- check : handles testing your project.
The build task, using task dependencies, makes sure that both assemble and check get run
##### 8.1 Java Plugin Task Graph :
![[Java-Plugin-Task-Graph.png]]

### 9. Axion-release-plugin for project versioning :
[Docs Link](https://github.com/allegro/axion-release-plugin)  (Need to learn correctly)
```kotlin
plugins {
    id("pl.allegro.tech.build.axion-release") version "1.18.7"
}

version = scmVersion.version
```

```shell
$ git tag
<empty list>

$ ./gradlew currentVersion
0.1.0-branch-SNAPSHOT

$ ./gradlew release

$ git tag
v0.1.0

$ ./gradlew cV
0.1.0

$ git add -A && git commit -m "Updates something" && ./gradlew release

$ git tag
v0.1.0
v0.1.1

$ ./gradlew cV
0.1.1
```
Instead of reading project version from buildfile, it is derived from nearest tag in SCM (or set to default if nothing was tagged). If current commit is tagged commit, project has a release version. If there were any commits after last tag, project is in SNAPSHOT version. This very simple and intuitive philosophy, alongside with [Semantic Versioning](http://semver.org/) rules, makes it a lot easier to manage project versions along SCM tag versions.

### 10. Optimizing Repositories :
Gradle search for the dependencies in the repositories, in numbered way they are declared. Thus to optimize the performance it's important to have correct repository order.
- This reduces unnecessary network calls, to the repository which does not have our dependency.
```shell
./gradlew build --refresh-dependencies --info --scan
```

### 11. Move Tasks to BuildSrc :
In this we move our task implementations to build source.
Build source is a special directory recognized by gradle, where we can put our custom tasks.
Why?
- Clean up build script (`build.gradle.kts`)(of specific project)
- Implementation separated from declaration
- Can reuse task in other projects build (for multi-project build)
![[Gradle-BuildSrc.png]]
[BuildSrc Info](https://handstandsam.com/2018/02/11/kotlin-buildsrc-for-better-gradle-dependency-management/)








### Continue Learning :
1. Other dependency Configurations (`compileOnly`, `runtimeOnly`)
2. locate and configure task
3. running java applications
4. application vs libraries





# References
1. [Gradle Doc](https://docs.gradle.org/current/userguide/userguide.html)
2. [YT video](https://youtu.be/R6Z-Sxb837I?si=ohftJx8PnfYwezEy)
3. [Baeldung - Old version](https://www.baeldung.com/gradle-series)
